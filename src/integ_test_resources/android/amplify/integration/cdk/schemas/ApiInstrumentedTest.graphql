type Person @model {
  id: ID!
  first_name: String!
  last_name: String!
  age: Int
  dob: AWSDate
  relationship: MaritalStatus
}

enum MaritalStatus {
    single
    engaged
    married
}
type Blog @model {
  id: ID!
  name: String!
  tags: [String]
  posts: [Post] @hasMany
}

type Rating @model {
  id: ID!
  stars: Int!
  post: Post! @hasMany
}

type Post @model {
  id: ID!
  title: String!
  blog: Blog! @hasMany(name: "BlogPosts")
  rating: Rating @hasMany(name: "PostRating")
  editors: [PostEditor] @belongsTo(keyName: "byPost", fields: ["id"])
}

# Create a join model and disable queries as you don't need them
# and can query through Post.editors and User.posts
type PostEditor
@model(queries: null)
@index(name: "byPost", fields: ["postID", "editorID"])
@index(name: "byEditor", fields: ["editorID", "postID"]) {
  id: ID!
  postID: ID!
  editorID: ID!
  post: Post! @belongsTo(fields: ["postID"])
  editor: User! @belongsTo(fields: ["editorID"])
}

type User @model {
  id: ID!
  username: String!
  posts: [PostEditor] @belongsTo(keyName: "byEditor", fields: ["id"])
}
type Projectfields @model {
  id: ID!
  name: String
  teamID: ID!
  team: Team @belongsTo(fields: ["teamID"])
}

type Team @model {
  id: ID!
  name: String!
}
type Event @model {
  id: ID!
  name: String!
  where: String!
  when: String!
  description: String
  comments: [Comment] @hasMany(name: "EventComments")
}

type Comment @model {
	eventId: ID!
	commentId: String!
	content: String!
	createdAt: String!
  event: Event @hasOne(name: "EventComments")
}

type Mutation {
  commentOnEvent(eventId: ID!, content: String!, createdAt: String!): Comment
}

type Subscription {
    subscribeToEventComments(eventId: String!): Comment @aws_subscribe(mutations: ["createComment"])
}

isengardcli assume --role ReadOnly --region us-east-1 amplify-android-dev+ops@amazon.com && eval ${isengardcli creds}