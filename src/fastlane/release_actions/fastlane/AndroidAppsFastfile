default_platform(:android)

platform :android do |options|
  version_regex = /(\d*)\.(\d*)\.(\d*)(?:-unstable\.)?(\d*)?/
  pr_body_checklist = %Q(
## Release PR review checklist
- [ ] Verify version name in gradle.properties
- [ ] Verify CHANGELOG.md
)

  desc "Fetch all tags to ensure accurate calculation of the next release number."
  before_all do 
    sh('git', 'fetch', '--tags')
    sh('git', 'fetch')
  end

  # Overridable lane that that allows for mapping of tag prefixes to gradle.properties files
  # Intended for multi-project setups where certain subprojects may be versioned
  # differently. Each consuming app should return a hash with the following data:
  # {
  #   repo: 'repo_owner/repo_name',
  #   product_name: 'My awesome library',
  #   releases: [
  #     {
  #       release_tag_prefix: 'release_v',
  #       gradle_properties_path: "#{project_root}/gradle.properties",
  #       doc_files_to_update: ["#{project_root}/README.md", "#{project_root}/rxbindings/README.md"],
  #       release_title: 'My main library',
  #       changelog_path: "#{project_root}/CHANGELOG.md",
  #     },
  #     {
  #       release_tag_prefix: 'release-somethingelse_v',
  #       gradle_properties_path: "#{project_root}/somethingelse/gradle.properties",
  #       doc_files_to_update: [],
  #       release_title: 'Amplify Android Kotlin Facade',
  #       changelog_path: "#{project_root}/somethingelse/CHANGELOG.md",
  #     }
  #   ]
  # }
  #   
  lane :build_parameters do
    raise ":build_parameters lane must be overridden in the consuming app's Fastfile."
  end

  lane :configure_git_options do |options|
    sh('git', 'config', 'user.email', options[:git_user_email])
    sh('git', 'config', 'user.name', options[:git_user_name])
  end

  # This lane is used to perform tasks necessary to create a PR for a release
  # of an Android-based library. To execute from your project, add the following to your
  # Fastfile:
  # 
  # ```
  # import_from_git(
  #     url: 'git@github.com:aws-amplify/amplify-ci-support.git',
  #     branch: 'android/fastlane-actions',
  #     path: './src/fastlane/release_actions/fastlane/AndroidAppsFastfile'
  # )
  # ```
  # 
  # To execute, run the following command from the directory where your Gemfile is located:
  # `bundle exec fastlane android create_next_release_pr dryrun:`
  #     dryrun: useful for testing localy. It runs the different steps but does not commit changes or creates the PR. Be sure to 
  #           pass this parameter with a colon at the end (without a value afterwards). See sample above.
  # files_to_commit = []
  github_releases = []
  lane :create_next_release_pr do |options|
    is_dryrun = options.has_key?(:dryrun)
    if options[:release_tag_override]
      release_tag_override = options[:release_tag_override].split(",")
    end

    product_name = build_parameters[:product_name]
    repo = build_parameters[:repo]

    pr_title = nil
    commit_slug = nil
    pr_body_details = []
    files_to_commit = []
    build_index = 0
    build_parameters[:releases].each do |params| 
      params[:repo] = repo
      if release_tag_override
        params[:release_tag_override] = release_tag_override[build_index]
      end
      release_title = params[:release_title]
      build_index += 1

      result = execute_changes_locally(params)
      next_version = result[:next_version]
      release_tag_name = result[:release_tag_name]
      changelog_body = result[:changelog_body]
      files_to_commit += result[:files_to_commit]
      
      puts("Token length = #{ENV["RELEASE_MANAGER_TOKEN"].length}")
      # We have to create separate Github releases for different products.
      # They can share one commit and the same PR, but if they have 
      # different versions, they should have different releases.
      github_releases << {
        repository_name: repo,
        api_bearer: ENV["RELEASE_MANAGER_TOKEN"],
        name: "#{release_title} #{next_version}",
        tag_name: release_tag_name,
        description: changelog_body,
        is_draft: true
      }

      pr_title = "release: #{product_name} #{next_version}" unless !pr_title.nil?
      commit_slug = "release: #{product_name} #{next_version}" unless !commit_slug.nil?
      pr_body_details << "#{product_name} #{next_version}"
    end
    pr_body = <<~END
      #{pr_body_checklist}

      ## Module versions

      #{pr_body_details.join('\\n')}
    END

    if is_dryrun
      dryrun_warning = %Q(
        RUNNING IN DRYRUN MODE - NOT PUSHING CHANGES OR CREATING PRs and RELEASES.

        The following would have happened:
        Files committed: #{files_to_commit}
         Commit message: #{commit_slug}
               PR title: #{pr_title}
                PR body: #{pr_body}
      )
      UI.message(dryrun_warning)
    else
      git_add(path: files_to_commit)
      git_commit(path: files_to_commit, message: commit_slug)
      push_to_git_remote(force: true)
      # Create the PR for the new release
      create_pull_request(base: 'main', 
        title: pr_title,
        body: pr_body,
        repo: repo, 
        api_bearer: ENV["RELEASE_MANAGER_TOKEN"]
      )
      # Create the new Github releases in draft status. This will be updated manually after the binaries get pushed to Maven.
      github_releases.each do |github_release|
        set_github_release(github_release)
      end
    end
  end

  private_lane :execute_changes_locally do |options|
    maven_group_name = CredentialsManager::AppfileConfig.try_fetch_value(:package_name)
    doc_files_to_update = options.has_key?(:doc_files_to_update) ? options[:doc_files_to_update] : []
    product_name = options[:product_name]
    release_tag_prefix = options[:release_tag_prefix]
    gradle_properties_path = options[:gradle_properties_path]
    changelog_path = options[:changelog_path]
    files_to_commit = [gradle_properties_path] 
    
    # Find the tag for the last release
    last_release_tag = last_git_tag(pattern: "#{release_tag_prefix}*")
    if options[:release_tag_override]
      last_release_tag = "#{release_tag_prefix}#{options[:release_tag_override]}"
    end
    last_version = last_release_tag.dup
    last_version.slice! "#{release_tag_prefix}"

    # Calculate the next version
    next_version, commits = calculate_next_release_version(release_tag_prefix: release_tag_prefix, from_tag: last_release_tag)
    # Build the tag name for the new release
    release_tag_name = "#{release_tag_prefix}#{next_version}"

    UI.message("Version change #{last_version} => #{next_version}")

    # Get the changelog body and append to the change log.
    changelog_body = generate_changelog(last_release_tag: last_release_tag)
    update_changelog(
      changelog_path: changelog_path,
      changelog_body: changelog_body,
      release_tag_prefix: release_tag_prefix,
      last_version: last_version,
      next_version: next_version,
      repo: options[:repo])
    files_to_commit << changelog_path
    # Update gradle.properties with the new version
    update_gradle_properties(version: next_version, gradle_properties_path: gradle_properties_path)
    # Update the version in the README.md file
    doc_files_to_update.each { |file_path| 
      UI.message("Updating doc file #{file_path}")
      update_docs(file_path:file_path, version: next_version, maven_group_name:maven_group_name)
      files_to_commit << file_path
    }
    # Return these values to the main lane.
    {
      files_to_commit: files_to_commit,
      release_tag_name: release_tag_name,
      next_version: next_version,
      changelog_body: changelog_body
    }
  end

  # Updates the version numbers in the README.md
  private_lane :update_docs do |options|
    readme_path = options[:file_path]
    readme_contents = File.read(readme_path)
    maven_group_name = options[:maven_group_name] 

    # Regex voodoo. \\1 refers to the module name which is the first capture group of the regex. We need that to rebuild the string with the new version.
    readme_contents = readme_contents.gsub(/implementation\s'#{maven_group_name}:(.*):(.*)'/,"implementation \'#{maven_group_name}:\\1:#{options[:version]}\'")
    open(readme_path, 'w') { |f|
      f.puts readme_contents
    }
  end
  
  # Generate the changelog notes for the new release.
  private_lane :generate_changelog do |options|
    releases = { 
      feat: "minor",
      fix: "patch", 
      chore: "patch",
      refactor: "patch",
      perf: "patch",
      test: "patch",
      docs: "patch",
      no_type: "patch"
    }

    # The analyze_commits function is a pre-requisite to running conventional_changelog. However, the versioning logic
    # used by analyze_commits increments the version number once for each commit that's part of the release. As a result,
    # you end up "wasting" version numbers. For example, your last release is 1.1.2 and you have 5 bug fixes to go in the
    # next release, the version calculated by analyze_commit would be 1.1.7. We'll just use the version number we
    # get from calculate_next_release_version. We'll use semantic_release for generating the change log since it has
    # a richer feature set.
    analyze_commits(match: "#{options[:last_release_tag]}", codepush_friendly:[], releases: releases)
    
    # We won't display the title generated by conventional_changelog because it will have the 
    # incorrect version.
    conventional_changelog(
      display_title: false,
      display_links: false,
      order: ["feat", "fix", "no_type"],
      sections: {
         feat: 'Features',
         fix: 'Bug Fixes',
         no_type: 'Miscellaneous'
      }
    )
  end
  
  desc "Append the changes to the CHANGELOG file."
  private_lane :update_changelog do |options|
    title = "## [Release #{options[:next_version]}](https://github.com/#{options[:repo]}/releases/tag/#{options[:release_tag_prefix]}#{options[:next_version]})"
    current_changelog = open(options[:changelog_path],'r').read unless !File.exists?(options[:changelog_path])
    open(options[:changelog_path], 'w') { |f|
      f.puts "#{title}\n\n"
      f.puts "#{options[:changelog_body]}\n\n"
      last_version_tag = "#{options[:release_tag_prefix]}#{options[:last_version]}"
      next_version_tag = "#{options[:release_tag_prefix]}#{options[:next_version]}"
      compare_tags = "#{last_version_tag}...#{next_version_tag}"
      diff_text = "See all changes between #{options[:last_version]} and #{options[:next_version]}"
      diff_link = "https://github.com/#{options[:repo]}/compare/#{compare_tags}"
      f.puts "[#{diff_text}](#{diff_link})"
      f.puts "\n"
      f.puts(current_changelog)
    }
  end

  desc "Increment versions"
  private_lane :update_gradle_properties do |options|
    version = options[:version].to_s
    segments = version.match(version_regex).captures # version.split('.')
    UI.message("Updating versionName in gradle.properties")
    set_key_value(file: options[:gradle_properties_path], key: 'VERSION_NAME', value: version)
  end
end
